// -*-C++-*-
#ifndef FUNHPC_ASYNC
#define FUNHPC_ASYNC

#include <cxx/invoke>
#include <funhpc/rexec>
#include <qthread/future>

#include <type_traits>

namespace funhpc {

// rlaunch /////////////////////////////////////////////////////////////////////

enum class rlaunch : unsigned {
  async = static_cast<unsigned>(qthread::launch::async),
  deferred = static_cast<unsigned>(qthread::launch::deferred),
  sync = static_cast<unsigned>(qthread::launch::sync),
  detached = static_cast<unsigned>(qthread::launch::detached),
};

inline constexpr rlaunch operator~(rlaunch a) {
  return static_cast<rlaunch>(~static_cast<unsigned>(a));
}

inline constexpr rlaunch operator&(rlaunch a, rlaunch b) {
  return static_cast<rlaunch>(static_cast<unsigned>(a) &
                              static_cast<unsigned>(b));
}
inline constexpr rlaunch operator|(rlaunch a, rlaunch b) {
  return static_cast<rlaunch>(static_cast<unsigned>(a) |
                              static_cast<unsigned>(b));
}
inline constexpr rlaunch operator^(rlaunch a, rlaunch b) {
  return static_cast<rlaunch>(static_cast<unsigned>(a) ^
                              static_cast<unsigned>(b));
}

inline rlaunch &
operator&=(rlaunch &a, rlaunch b) {
  return a = a & b;
}
inline rlaunch &operator|=(rlaunch &a, rlaunch b) { return a = a | b; }
inline rlaunch &operator^=(rlaunch &a, rlaunch b) { return a = a ^ b; }

namespace detail {
// Convert bitmask to a specific policy
constexpr rlaunch decode_policy(rlaunch policy) {
  if ((policy | rlaunch::async) == rlaunch::async)
    return rlaunch::async;
  if ((policy | rlaunch::deferred) == rlaunch::deferred)
    return rlaunch::deferred;
  if ((policy | rlaunch::sync) == rlaunch::sync)
    return rlaunch::sync;
  if ((policy | rlaunch::detached) == rlaunch::detached)
    return rlaunch::detached;
  return rlaunch::async;
}

// Convert policy to a local policy
constexpr qthread::launch local_policy(rlaunch policy) {
  return static_cast<qthread::launch>(policy);
}
}

// async ///////////////////////////////////////////////////////////////////////

namespace detail {
template <typename R> void set_result(uintptr_t ipres, R &res) {
  static_assert(!std::is_void<R>::value, "");
  auto pres = (qthread::promise<R> *)(ipres);
  pres->set_value(std::move(res));
  delete pres;
}
template <typename R> void set_result_void(uintptr_t ipres) {
  static_assert(std::is_void<R>::value, "");
  auto pres = (qthread::promise<R> *)(ipres);
  pres->set_value();
  delete pres;
}

template <typename F, typename... Args,
          typename R = cxx::invoke_of_t<std::decay_t<F>, std::decay_t<Args>...>,
          std::enable_if_t<!std::is_void<R>::value> * = nullptr>
void continued(std::size_t origin, uintptr_t ipres, F &f, Args &... args) {
  rexec(origin, set_result<R>, ipres,
        cxx::invoke(std::move(f), std::move(args)...));
}
template <typename F, typename... Args,
          typename R = cxx::invoke_of_t<std::decay_t<F>, std::decay_t<Args>...>,
          std::enable_if_t<std::is_void<R>::value> * = nullptr>
void continued(std::size_t origin, uintptr_t ipres, F &f, Args &... args) {
  cxx::invoke(std::move(f), std::move(args)...);
  rexec(origin, set_result_void<R>, ipres);
}
}

template <typename F, typename... Args,
          typename R = cxx::invoke_of_t<std::decay_t<F>, std::decay_t<Args>...>>
qthread::future<R> async(rlaunch policy, std::size_t dest, F &&f,
                         Args &&... args) {
  if (dest == rank())
    return qthread::async(detail::local_policy(policy), std::forward<F>(f),
                          std::forward<Args>(args)...);
  auto pol = detail::decode_policy(policy);
  switch (pol) {
  case rlaunch::async:
  case rlaunch::sync: {
    auto pres = new qthread::promise<R>;
    auto fres = pres->get_future();
    rexec(dest, detail::continued<std::decay_t<F>, std::decay_t<Args>...>,
          rank(), uintptr_t(pres), std::forward<F>(f),
          std::forward<Args>(args)...);
    if (pol == rlaunch::sync)
      fres.wait();
    return fres;
  }
  case rlaunch::deferred: {
    return qthread::async(qthread::launch::deferred,
                          [dest](auto f, auto... args) {
                            return async(rlaunch::async, dest, std::move(f),
                                         std::move(args)...).get();
                          },
                          std::forward<F>(f), std::forward<Args>(args)...);
  }
  case rlaunch::detached: {
    rexec(dest, std::forward<F>(f), std::forward<Args>(args)...);
    return qthread::future<R>();
  }
  }
}
}

#define FUNHPC_ASYNC_DONE
#endif // #ifdef FUNHPC_ASYNC
#ifndef FUNHPC_ASYNC_DONE
#error "Cyclic include dependency"
#endif
